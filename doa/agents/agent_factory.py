"""Agent factory for creating LangGraph agent nodes with consistent patterns."""

import asyncio
import logging
import time
from typing import Any, Awaitable, Callable, Dict, List, Optional

from langchain_core.messages import HumanMessage, SystemMessage

from config import EngineConfig
from models.state import GraphState
from models.types import AgentError, AgentMemoryContext, AgentSignal
from utils.llm_factory import create_agent_llm

logger = logging.getLogger(__name__)


def format_memory_context(
    memory_context: Optional[AgentMemoryContext],
    agent_name: str
) -> str:
    """
    Format historical memory context for injection into agent prompts.
    
    Args:
        memory_context: Historical signals for this agent
        agent_name: Name of the agent
        
    Returns:
        Formatted memory context string for prompt injection
    """
    if not memory_context or not memory_context.historical_signals:
        return "\n## Historical Context\n\nNo previous analysis available for this market."
    
    context_lines = ["\n## Historical Context"]
    context_lines.append(
        f"\nYou have analyzed this market {len(memory_context.historical_signals)} time(s) before. "
        "Here are your previous signals:\n"
    )
    
    for i, signal in enumerate(memory_context.historical_signals, 1):
        timestamp_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(signal.timestamp))
        context_lines.append(f"\n### Previous Analysis {i} ({timestamp_str})")
        context_lines.append(f"- Direction: {signal.direction}")
        context_lines.append(f"- Fair Probability: {signal.fair_probability:.2%}")
        context_lines.append(f"- Confidence: {signal.confidence:.2%}")
        context_lines.append(f"- Key Drivers: {', '.join(signal.key_drivers)}")
        context_lines.append(f"- Risk Factors: {', '.join(signal.risk_factors)}")
    
    context_lines.append(
        "\n**Note**: Use this historical context to inform your current analysis, "
        "but base your decision on the current market data provided."
    )
    
    return "\n".join(context_lines)


def format_market_briefing(mbd: Any) -> str:
    """
    Format Market Briefing Document for agent consumption.
    
    Args:
        mbd: MarketBriefingDocument instance
        
    Returns:
        Formatted market briefing string
    """
    lines = [
        "# Market Briefing Document",
        f"\n## Market Overview",
        f"- Question: {mbd.question}",
        f"- Market ID: {mbd.market_id}",
        f"- Condition ID: {mbd.condition_id}",
        f"- Event Type: {mbd.event_type}",
        f"\n## Current Market State",
        f"- Current Probability: {mbd.current_probability:.2%}",
        f"- Liquidity Score: {mbd.liquidity_score:.1f}/10",
        f"- Bid-Ask Spread: {mbd.bid_ask_spread:.2f} cents",
        f"- Volatility Regime: {mbd.volatility_regime}",
        f"- 24h Volume: ${mbd.volume_24h:,.2f}",
        f"\n## Resolution",
        f"- Criteria: {mbd.resolution_criteria}",
        f"- Expiry: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(mbd.expiry_timestamp))}",
    ]
    
    # Add event context if available
    if mbd.event_context:
        lines.extend([
            f"\n## Event Context",
            f"- Event: {mbd.event_context.event_title}",
            f"- Description: {mbd.event_context.event_description}",
            f"- Tags: {', '.join(mbd.event_context.tags)}",
        ])
    
    # Add keywords if available
    if mbd.keywords:
        lines.append(f"\n## Keywords")
        lines.append(f"- {', '.join(mbd.keywords)}")
    
    return "\n".join(lines)


async def execute_agent_with_timeout(
    agent_fn: Callable[[], Awaitable[AgentSignal]],
    agent_name: str,
    timeout_ms: int
) -> Dict[str, Any]:
    """
    Execute an agent with timeout handling.
    
    Args:
        agent_fn: Async function that executes the agent
        agent_name: Name of the agent (for error reporting)
        timeout_ms: Timeout in milliseconds
        
    Returns:
        Dict with either agent_signals or agent_errors
    """
    try:
        signal = await asyncio.wait_for(
            agent_fn(),
            timeout=timeout_ms / 1000
        )
        return {"agent_signals": [signal]}
        
    except asyncio.TimeoutError:
        logger.warning(f"Agent {agent_name} timed out after {timeout_ms}ms")
        return {
            "agent_errors": [AgentError(
                type="TIMEOUT",
                agent_name=agent_name,
                message=f"Agent execution exceeded timeout of {timeout_ms}ms",
                timeout_ms=timeout_ms
            )]
        }
    except Exception as e:
        logger.error(f"Agent {agent_name} execution failed: {e}", exc_info=True)
        return {
            "agent_errors": [AgentError(
                type="EXECUTION_FAILED",
                agent_name=agent_name,
                message=str(e),
                details={"error_type": type(e).__name__}
            )]
        }


async def retry_with_backoff(
    agent_fn: Callable[[], Awaitable[AgentSignal]],
    agent_name: str,
    max_retries: int = 3,
    initial_delay: float = 1.0
) -> AgentSignal:
    """
    Retry agent execution with exponential backoff for invalid structured output.
    
    Args:
        agent_fn: Async function that executes the agent
        agent_name: Name of the agent (for logging)
        max_retries: Maximum number of retry attempts
        initial_delay: Initial delay in seconds (doubles each retry)
        
    Returns:
        AgentSignal from successful execution
        
    Raises:
        Exception: If all retries fail
    """
    last_error = None
    delay = initial_delay
    
    for attempt in range(max_retries):
        try:
            return await agent_fn()
        except Exception as e:
            last_error = e
            if attempt < max_retries - 1:
                logger.warning(
                    f"Agent {agent_name} attempt {attempt + 1} failed: {e}. "
                    f"Retrying in {delay}s..."
                )
                await asyncio.sleep(delay)
                delay *= 2  # Exponential backoff
            else:
                logger.error(
                    f"Agent {agent_name} failed after {max_retries} attempts"
                )
    
    raise last_error


def create_agent_node(
    agent_name: str,
    system_prompt: str,
    config: EngineConfig
) -> Callable[[GraphState], Awaitable[Dict[str, Any]]]:
    """
    Create a LangGraph node for an intelligence agent.
    
    This factory function creates agent nodes with consistent patterns:
    - Memory context formatting and injection
    - Timeout handling with graceful degradation
    - Retry logic for invalid structured output
    - Structured error handling
    - Opik tracing integration
    
    Args:
        agent_name: Unique identifier for the agent (e.g., "market_microstructure")
        system_prompt: System prompt defining agent's analysis perspective
        config: Engine configuration with LLM, timeout, and retry settings
        
    Returns:
        Async function that takes GraphState and returns state update dict
        
    Example:
        >>> from prompts import MARKET_MICROSTRUCTURE_PROMPT
        >>> market_microstructure_node = create_agent_node(
        ...     agent_name="market_microstructure",
        ...     system_prompt=MARKET_MICROSTRUCTURE_PROMPT,
        ...     config=engine_config
        ... )
    """
    
    async def agent_node(state: GraphState) -> Dict[str, Any]:
        """
        Agent node function that analyzes market and returns AgentSignal.
        
        Args:
            state: Current workflow state with MBD and memory context
            
        Returns:
            Dict with agent_signals (on success) or agent_errors (on failure)
        """
        logger.info(f"Executing agent: {agent_name}")
        
        # Validate required state
        if not state.get("mbd"):
            logger.error(f"Agent {agent_name}: No MBD in state")
            return {
                "agent_errors": [AgentError(
                    type="EXECUTION_FAILED",
                    agent_name=agent_name,
                    message="No Market Briefing Document available in state"
                )]
            }
        
        mbd = state["mbd"]
        
        # Get memory context for this agent
        memory_context = state.get("memory_context", {}).get(agent_name)
        
        # Format memory context
        memory_str = format_memory_context(memory_context, agent_name)
        
        # Format market briefing
        market_briefing = format_market_briefing(mbd)
        
        # Construct full prompt with memory context
        full_system_prompt = f"{system_prompt}\n\n{memory_str}"
        
        # Create LLM instance with structured output
        try:
            llm = create_agent_llm(
                config=config,
                agent_name=agent_name,
                output_model=AgentSignal
            )
        except Exception as e:
            logger.error(f"Failed to create LLM for agent {agent_name}: {e}")
            return {
                "agent_errors": [AgentError(
                    type="EXECUTION_FAILED",
                    agent_name=agent_name,
                    message=f"Failed to initialize LLM: {e}"
                )]
            }
        
        # Define agent execution function
        async def execute_agent() -> AgentSignal:
            """Execute the agent with retry logic."""
            messages = [
                SystemMessage(content=full_system_prompt),
                HumanMessage(content=market_briefing)
            ]
            
            # Invoke LLM with structured output
            signal = await llm.ainvoke(messages)
            
            # Ensure agent_name and timestamp are set
            signal.agent_name = agent_name
            signal.timestamp = int(time.time())
            
            logger.info(
                f"Agent {agent_name} completed: "
                f"direction={signal.direction}, "
                f"fair_probability={signal.fair_probability:.2%}, "
                f"confidence={signal.confidence:.2%}"
            )
            
            return signal
        
        # Execute with retry logic
        async def execute_with_retry() -> AgentSignal:
            return await retry_with_backoff(
                execute_agent,
                agent_name=agent_name,
                max_retries=config.agents.max_retries
            )
        
        # Execute with timeout
        result = await execute_agent_with_timeout(
            execute_with_retry,
            agent_name=agent_name,
            timeout_ms=config.agents.timeout_ms
        )
        
        return result
    
    return agent_node

